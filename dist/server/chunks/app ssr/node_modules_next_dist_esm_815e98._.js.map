{
  "version": 3,
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/shared/lib/lazy-dynamic/no-ssr-error.js"],"sourcesContent":["// This has to be a shared module which is shared between client component error boundary and dynamic component\nexport const NEXT_DYNAMIC_NO_SSR_CODE = \"NEXT_DYNAMIC_NO_SSR_CODE\";\n\n//# sourceMappingURL=no-ssr-error.js.map"],"names":[],"mappings":"AAAA,+GAA+G;;;;AACxG,MAAM,2BAA2B,4BAExC,wCAAwC"}},
    {"offset": {"line": 9, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/shared/lib/lazy-dynamic/dynamic-no-ssr.js"],"sourcesContent":["\"use client\";\n\nimport { NEXT_DYNAMIC_NO_SSR_CODE } from \"./no-ssr-error\";\nexport function suspense() {\n    const error = new Error(NEXT_DYNAMIC_NO_SSR_CODE);\n    error.digest = NEXT_DYNAMIC_NO_SSR_CODE;\n    throw error;\n}\nexport function NoSSR(param) {\n    let { children } = param;\n    if (typeof window === \"undefined\") {\n        suspense();\n    }\n    return children;\n}\n\n//# sourceMappingURL=dynamic-no-ssr.js.map"],"names":[],"mappings":";;;;;;AAAA;;AAGO,SAAS;IACZ,MAAM,QAAQ,IAAI;IAClB,MAAM,MAAM;IACZ,MAAM;AACV;AACO,SAAS,MAAM,KAAK;IACvB,IAAI,EAAE,QAAQ,EAAE,GAAG;IACnB,IAAI,OAAO,WAAW,aAAa;QAC/B;IACJ;IACA,OAAO;AACX,EAEA,0CAA0C"}},
    {"offset": {"line": 33, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 37, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/shared/lib/router/utils/handle-smooth-scroll.js"],"sourcesContent":["/**\n * Run function with `scroll-behavior: auto` applied to `<html/>`.\n * This css change will be reverted after the function finishes.\n */ export function handleSmoothScroll(fn, options) {\n    if (options === void 0) options = {};\n    // if only the hash is changed, we don't need to disable smooth scrolling\n    // we only care to prevent smooth scrolling when navigating to a new page to avoid jarring UX\n    if (options.onlyHashChange) {\n        fn();\n        return;\n    }\n    const htmlElement = document.documentElement;\n    const existing = htmlElement.style.scrollBehavior;\n    htmlElement.style.scrollBehavior = \"auto\";\n    if (!options.dontForceLayout) {\n        // In Chrome-based browsers we need to force reflow before calling `scrollTo`.\n        // Otherwise it will not pickup the change in scrollBehavior\n        // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042\n        htmlElement.getClientRects();\n    }\n    fn();\n    htmlElement.style.scrollBehavior = existing;\n}\n\n//# sourceMappingURL=handle-smooth-scroll.js.map"],"names":[],"mappings":"AAAA;;;CAGC;;;AAAU,SAAS,mBAAmB,EAAE,EAAE,OAAO;IAC9C,IAAI,YAAY,KAAK,GAAG,UAAU,CAAC;IACnC,yEAAyE;IACzE,6FAA6F;IAC7F,IAAI,QAAQ,cAAc,EAAE;QACxB;QACA;IACJ;IACA,MAAM,cAAc,SAAS,eAAe;IAC5C,MAAM,WAAW,YAAY,KAAK,CAAC,cAAc;IACjD,YAAY,KAAK,CAAC,cAAc,GAAG;IACnC,IAAI,CAAC,QAAQ,eAAe,EAAE;QAC1B,8EAA8E;QAC9E,4DAA4D;QAC5D,yFAAyF;QACzF,YAAY,cAAc;IAC9B;IACA;IACA,YAAY,KAAK,CAAC,cAAc,GAAG;AACvC,EAEA,gDAAgD"}},
    {"offset": {"line": 63, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 67, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/shared/lib/segment.js"],"sourcesContent":["export function isGroupSegment(segment) {\n    // Use array[0] for performant purpose\n    return segment[0] === \"(\" && segment.endsWith(\")\");\n}\n\n//# sourceMappingURL=segment.js.map"],"names":[],"mappings":";;;AAAO,SAAS,eAAe,OAAO;IAClC,sCAAsC;IACtC,OAAO,OAAO,CAAC,EAAE,KAAK,OAAO,QAAQ,QAAQ,CAAC;AAClD,EAEA,mCAAmC"}},
    {"offset": {"line": 74, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 78, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/shared/lib/page-path/ensure-leading-slash.js"],"sourcesContent":["/**\n * For a given page path, this function ensures that there is a leading slash.\n * If there is not a leading slash, one is added, otherwise it is noop.\n */ export function ensureLeadingSlash(path) {\n    return path.startsWith(\"/\") ? path : \"/\" + path;\n}\n\n//# sourceMappingURL=ensure-leading-slash.js.map"],"names":[],"mappings":"AAAA;;;CAGC;;;AAAU,SAAS,mBAAmB,IAAI;IACvC,OAAO,KAAK,UAAU,CAAC,OAAO,OAAO,MAAM;AAC/C,EAEA,gDAAgD"}},
    {"offset": {"line": 87, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 91, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/shared/lib/router/utils/app-paths.js"],"sourcesContent":["import { ensureLeadingSlash } from \"../../page-path/ensure-leading-slash\";\nimport { isGroupSegment } from \"../../segment\";\n/**\n * Normalizes an app route so it represents the actual request path. Essentially\n * performing the following transformations:\n *\n * - `/(dashboard)/user/[id]/page` to `/user/[id]`\n * - `/(dashboard)/account/page` to `/account`\n * - `/user/[id]/page` to `/user/[id]`\n * - `/account/page` to `/account`\n * - `/page` to `/`\n * - `/(dashboard)/user/[id]/route` to `/user/[id]`\n * - `/(dashboard)/account/route` to `/account`\n * - `/user/[id]/route` to `/user/[id]`\n * - `/account/route` to `/account`\n * - `/route` to `/`\n * - `/` to `/`\n *\n * @param route the app route to normalize\n * @returns the normalized pathname\n */ export function normalizeAppPath(route) {\n    return ensureLeadingSlash(route.split(\"/\").reduce((pathname, segment, index, segments)=>{\n        // Empty segments are ignored.\n        if (!segment) {\n            return pathname;\n        }\n        // Groups are ignored.\n        if (isGroupSegment(segment)) {\n            return pathname;\n        }\n        // Parallel segments are ignored.\n        if (segment[0] === \"@\") {\n            return pathname;\n        }\n        // The last segment (if it's a leaf) should be ignored.\n        if ((segment === \"page\" || segment === \"route\") && index === segments.length - 1) {\n            return pathname;\n        }\n        return pathname + \"/\" + segment;\n    }, \"\"));\n}\n/**\n * Strips the `.rsc` extension if it's in the pathname.\n * Since this function is used on full urls it checks `?` for searchParams handling.\n */ export function normalizeRscPath(pathname, enabled) {\n    return enabled ? pathname.replace(/\\.rsc($|\\?)/, // $1 ensures `?` is preserved\n    \"$1\") : pathname;\n}\n\n//# sourceMappingURL=app-paths.js.map"],"names":[],"mappings":";;;;;;;;;AAoBW,SAAS,iBAAiB,KAAK;IACtC,OAAO,qMAAmB,MAAM,KAAK,CAAC,KAAK,MAAM,CAAC,CAAC,UAAU,SAAS,OAAO;QACzE,8BAA8B;QAC9B,IAAI,CAAC,SAAS;YACV,OAAO;QACX;QACA,sBAAsB;QACtB,IAAI,8JAAe,UAAU;YACzB,OAAO;QACX;QACA,iCAAiC;QACjC,IAAI,OAAO,CAAC,EAAE,KAAK,KAAK;YACpB,OAAO;QACX;QACA,uDAAuD;QACvD,IAAI,CAAC,YAAY,UAAU,YAAY,OAAO,KAAK,UAAU,SAAS,MAAM,GAAG,GAAG;YAC9E,OAAO;QACX;QACA,OAAO,WAAW,MAAM;IAC5B,GAAG;AACP;AAIW,SAAS,iBAAiB,QAAQ,EAAE,OAAO;IAClD,OAAO,UAAU,SAAS,OAAO,CAAC,eAClC,QAAQ;AACZ,EAEA,qCAAqC"}},
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 128, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/shared/lib/hash.js"],"sourcesContent":["// http://www.cse.yorku.ca/~oz/hash.html\nexport function djb2Hash(str) {\n    let hash = 5381;\n    for(let i = 0; i < str.length; i++){\n        const char = str.charCodeAt(i);\n        hash = (hash << 5) + hash + char;\n    }\n    return Math.abs(hash);\n}\nexport function hexHash(str) {\n    return djb2Hash(str).toString(36).slice(0, 5);\n}\n\n//# sourceMappingURL=hash.js.map"],"names":[],"mappings":"AAAA,wCAAwC;;;;;AACjC,SAAS,SAAS,GAAG;IACxB,IAAI,OAAO;IACX,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,IAAI;QAC/B,MAAM,OAAO,IAAI,UAAU,CAAC;QAC5B,OAAO,CAAC,QAAQ,CAAC,IAAI,OAAO;IAChC;IACA,OAAO,KAAK,GAAG,CAAC;AACpB;AACO,SAAS,QAAQ,GAAG;IACvB,OAAO,SAAS,KAAK,QAAQ,CAAC,IAAI,KAAK,CAAC,GAAG;AAC/C,EAEA,gCAAgC"}},
    {"offset": {"line": 144, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/shared/lib/router/utils/parse-path.js"],"sourcesContent":["/**\n * Given a path this function will find the pathname, query and hash and return\n * them. This is useful to parse full paths on the client side.\n * @param path A path to parse e.g. /foo/bar?id=1#hash\n */ export function parsePath(path) {\n    const hashIndex = path.indexOf(\"#\");\n    const queryIndex = path.indexOf(\"?\");\n    const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);\n    if (hasQuery || hashIndex > -1) {\n        return {\n            pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),\n            query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined) : \"\",\n            hash: hashIndex > -1 ? path.slice(hashIndex) : \"\"\n        };\n    }\n    return {\n        pathname: path,\n        query: \"\",\n        hash: \"\"\n    };\n}\n\n//# sourceMappingURL=parse-path.js.map"],"names":[],"mappings":"AAAA;;;;CAIC;;;AAAU,SAAS,UAAU,IAAI;IAC9B,MAAM,YAAY,KAAK,OAAO,CAAC;IAC/B,MAAM,aAAa,KAAK,OAAO,CAAC;IAChC,MAAM,WAAW,aAAa,CAAC,KAAK,CAAC,YAAY,KAAK,aAAa,SAAS;IAC5E,IAAI,YAAY,YAAY,CAAC,GAAG;QAC5B,OAAO;YACH,UAAU,KAAK,SAAS,CAAC,GAAG,WAAW,aAAa;YACpD,OAAO,WAAW,KAAK,SAAS,CAAC,YAAY,YAAY,CAAC,IAAI,YAAY,aAAa;YACvF,MAAM,YAAY,CAAC,IAAI,KAAK,KAAK,CAAC,aAAa;QACnD;IACJ;IACA,OAAO;QACH,UAAU;QACV,OAAO;QACP,MAAM;IACV;AACJ,EAEA,sCAAsC"}},
    {"offset": {"line": 172, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 176, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/shared/lib/router/utils/path-has-prefix.js"],"sourcesContent":["import { parsePath } from \"./parse-path\";\n/**\n * Checks if a given path starts with a given prefix. It ensures it matches\n * exactly without containing extra chars. e.g. prefix /docs should replace\n * for /docs, /docs/, /docs/a but not /docsss\n * @param path The path to check.\n * @param prefix The prefix to check against.\n */ export function pathHasPrefix(path, prefix) {\n    if (typeof path !== \"string\") {\n        return false;\n    }\n    const { pathname } = parsePath(path);\n    return pathname === prefix || pathname.startsWith(prefix + \"/\");\n}\n\n//# sourceMappingURL=path-has-prefix.js.map"],"names":[],"mappings":";;;;;;AAOW,SAAS,cAAc,IAAI,EAAE,MAAM;IAC1C,IAAI,OAAO,SAAS,UAAU;QAC1B,OAAO;IACX;IACA,MAAM,EAAE,QAAQ,EAAE,GAAG,kLAAU;IAC/B,OAAO,aAAa,UAAU,SAAS,UAAU,CAAC,SAAS;AAC/D,EAEA,2CAA2C"}},
    {"offset": {"line": 189, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 193, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/shared/lib/router/utils/remove-trailing-slash.js"],"sourcesContent":["/**\n * Removes the trailing slash for a given route or page path. Preserves the\n * root page. Examples:\n *   - `/foo/bar/` -> `/foo/bar`\n *   - `/foo/bar` -> `/foo/bar`\n *   - `/` -> `/`\n */ export function removeTrailingSlash(route) {\n    return route.replace(/\\/$/, \"\") || \"/\";\n}\n\n//# sourceMappingURL=remove-trailing-slash.js.map"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;AAAU,SAAS,oBAAoB,KAAK;IACzC,OAAO,MAAM,OAAO,CAAC,OAAO,OAAO;AACvC,EAEA,iDAAiD"}},
    {"offset": {"line": 205, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 209, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/shared/lib/router/utils/add-path-prefix.js"],"sourcesContent":["import { parsePath } from \"./parse-path\";\n/**\n * Adds the provided prefix to the given path. It first ensures that the path\n * is indeed starting with a slash.\n */ export function addPathPrefix(path, prefix) {\n    if (!path.startsWith(\"/\") || !prefix) {\n        return path;\n    }\n    const { pathname, query, hash } = parsePath(path);\n    return \"\" + prefix + pathname + query + hash;\n}\n\n//# sourceMappingURL=add-path-prefix.js.map"],"names":[],"mappings":";;;;;;AAIW,SAAS,cAAc,IAAI,EAAE,MAAM;IAC1C,IAAI,CAAC,KAAK,UAAU,CAAC,QAAQ,CAAC,QAAQ;QAClC,OAAO;IACX;IACA,MAAM,EAAE,QAAQ,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,kLAAU;IAC5C,OAAO,KAAK,SAAS,WAAW,QAAQ;AAC5C,EAEA,2CAA2C"}},
    {"offset": {"line": 222, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 226, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/shared/lib/router/utils/is-bot.js"],"sourcesContent":["export function isBot(userAgent) {\n    return /Googlebot|Mediapartners-Google|AdsBot-Google|googleweblight|Storebot-Google|Google-PageRenderer|Bingbot|BingPreview|Slurp|DuckDuckBot|baiduspider|yandex|sogou|LinkedInBot|bitlybot|tumblr|vkShare|quora link preview|facebookexternalhit|facebookcatalog|Twitterbot|applebot|redditbot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|ia_archiver/i.test(userAgent);\n}\n\n//# sourceMappingURL=is-bot.js.map"],"names":[],"mappings":";;;AAAO,SAAS,MAAM,SAAS;IAC3B,OAAO,oVAAoV,IAAI,CAAC;AACpW,EAEA,kCAAkC"}},
    {"offset": {"line": 232, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 236, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/server/future/helpers/interception-routes.js"],"sourcesContent":["import { normalizeAppPath } from \"../../../shared/lib/router/utils/app-paths\";\n// order matters here, the first match will be used\nexport const INTERCEPTION_ROUTE_MARKERS = [\n    \"(..)(..)\",\n    \"(.)\",\n    \"(..)\",\n    \"(...)\"\n];\nexport function isInterceptionRouteAppPath(path) {\n    // TODO-APP: add more serious validation\n    return path.split(\"/\").find((segment)=>INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m))) !== undefined;\n}\nexport function extractInterceptionRouteInformation(path) {\n    let interceptingRoute, marker, interceptedRoute;\n    for (const segment of path.split(\"/\")){\n        marker = INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));\n        if (marker) {\n            [interceptingRoute, interceptedRoute] = path.split(marker, 2);\n            break;\n        }\n    }\n    if (!interceptingRoute || !marker || !interceptedRoute) {\n        throw new Error(`Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`);\n    }\n    interceptingRoute = normalizeAppPath(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n    ;\n    switch(marker){\n        case \"(.)\":\n            // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n            if (interceptingRoute === \"/\") {\n                interceptedRoute = `/${interceptedRoute}`;\n            } else {\n                interceptedRoute = interceptingRoute + \"/\" + interceptedRoute;\n            }\n            break;\n        case \"(..)\":\n            // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n            if (interceptingRoute === \"/\") {\n                throw new Error(`Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`);\n            }\n            interceptedRoute = interceptingRoute.split(\"/\").slice(0, -1).concat(interceptedRoute).join(\"/\");\n            break;\n        case \"(...)\":\n            // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n            interceptedRoute = \"/\" + interceptedRoute;\n            break;\n        case \"(..)(..)\":\n            // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n            const splitInterceptingRoute = interceptingRoute.split(\"/\");\n            if (splitInterceptingRoute.length <= 2) {\n                throw new Error(`Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`);\n            }\n            interceptedRoute = splitInterceptingRoute.slice(0, -2).concat(interceptedRoute).join(\"/\");\n            break;\n        default:\n            throw new Error(\"Invariant: unexpected marker\");\n    }\n    return {\n        interceptingRoute,\n        interceptedRoute\n    };\n}\n\n//# sourceMappingURL=interception-routes.js.map"],"names":[],"mappings":";;;;;;;;AAEO,MAAM,6BAA6B;IACtC;IACA;IACA;IACA;CACH;AACM,SAAS,2BAA2B,IAAI;IAC3C,wCAAwC;IACxC,OAAO,KAAK,KAAK,CAAC,KAAK,IAAI,CAAC,CAAC,UAAU,2BAA2B,IAAI,CAAC,CAAC,IAAI,QAAQ,UAAU,CAAC,SAAS;AAC5G;AACO,SAAS,oCAAoC,IAAI;IACpD,IAAI,mBAAmB,QAAQ;IAC/B,KAAK,MAAM,WAAW,KAAK,KAAK,CAAC,KAAK;QAClC,SAAS,2BAA2B,IAAI,CAAC,CAAC,IAAI,QAAQ,UAAU,CAAC;QACjE,IAAI,QAAQ;YACR,CAAC,mBAAmB,iBAAiB,GAAG,KAAK,KAAK,CAAC,QAAQ;YAC3D;QACJ;IACJ;IACA,IAAI,CAAC,qBAAqB,CAAC,UAAU,CAAC,kBAAkB;QACpD,MAAM,IAAI,MAAM,CAAC,4BAA4B,EAAE,KAAK,iFAAiF,CAAC;IAC1I;IACA,oBAAoB,wLAAiB,mBAAmB,iDAAiD;;IAEzG,OAAO;QACH,KAAK;YACD,oIAAoI;YACpI,IAAI,sBAAsB,KAAK;gBAC3B,mBAAmB,CAAC,CAAC,EAAE,iBAAiB,CAAC;YAC7C,OAAO;gBACH,mBAAmB,oBAAoB,MAAM;YACjD;YACA;QACJ,KAAK;YACD,uHAAuH;YACvH,IAAI,sBAAsB,KAAK;gBAC3B,MAAM,IAAI,MAAM,CAAC,4BAA4B,EAAE,KAAK,4DAA4D,CAAC;YACrH;YACA,mBAAmB,kBAAkB,KAAK,CAAC,KAAK,KAAK,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,kBAAkB,IAAI,CAAC;YAC3F;QACJ,KAAK;YACD,kIAAkI;YAClI,mBAAmB,MAAM;YACzB;QACJ,KAAK;YACD,iIAAiI;YACjI,MAAM,yBAAyB,kBAAkB,KAAK,CAAC;YACvD,IAAI,uBAAuB,MAAM,IAAI,GAAG;gBACpC,MAAM,IAAI,MAAM,CAAC,4BAA4B,EAAE,KAAK,+DAA+D,CAAC;YACxH;YACA,mBAAmB,uBAAuB,KAAK,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,kBAAkB,IAAI,CAAC;YACrF;QACJ;YACI,MAAM,IAAI,MAAM;IACxB;IACA,OAAO;QACH;QACA;IACJ;AACJ,EAEA,+CAA+C"}},
    {"offset": {"line": 304, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 308, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/server/app-render/get-segment-param.js"],"sourcesContent":["import { INTERCEPTION_ROUTE_MARKERS } from \"../future/helpers/interception-routes\";\n/**\n * Parse dynamic route segment to type of parameter\n */ export function getSegmentParam(segment) {\n    const interceptionMarker = INTERCEPTION_ROUTE_MARKERS.find((marker)=>segment.startsWith(marker));\n    // if an interception marker is part of the path segment, we need to jump ahead\n    // to the relevant portion for param parsing\n    if (interceptionMarker) {\n        segment = segment.slice(interceptionMarker.length);\n    }\n    if (segment.startsWith(\"[[...\") && segment.endsWith(\"]]\")) {\n        return {\n            type: \"optional-catchall\",\n            param: segment.slice(5, -2)\n        };\n    }\n    if (segment.startsWith(\"[...\") && segment.endsWith(\"]\")) {\n        return {\n            type: \"catchall\",\n            param: segment.slice(4, -1)\n        };\n    }\n    if (segment.startsWith(\"[\") && segment.endsWith(\"]\")) {\n        return {\n            type: \"dynamic\",\n            param: segment.slice(1, -1)\n        };\n    }\n    return null;\n}\n\n//# sourceMappingURL=get-segment-param.js.map"],"names":[],"mappings":";;;;;;AAGW,SAAS,gBAAgB,OAAO;IACvC,MAAM,qBAAqB,uMAA2B,IAAI,CAAC,CAAC,SAAS,QAAQ,UAAU,CAAC;IACxF,+EAA+E;IAC/E,4CAA4C;IAC5C,IAAI,oBAAoB;QACpB,UAAU,QAAQ,KAAK,CAAC,mBAAmB,MAAM;IACrD;IACA,IAAI,QAAQ,UAAU,CAAC,YAAY,QAAQ,QAAQ,CAAC,OAAO;QACvD,OAAO;YACH,MAAM;YACN,OAAO,QAAQ,KAAK,CAAC,GAAG,CAAC;QAC7B;IACJ;IACA,IAAI,QAAQ,UAAU,CAAC,WAAW,QAAQ,QAAQ,CAAC,MAAM;QACrD,OAAO;YACH,MAAM;YACN,OAAO,QAAQ,KAAK,CAAC,GAAG,CAAC;QAC7B;IACJ;IACA,IAAI,QAAQ,UAAU,CAAC,QAAQ,QAAQ,QAAQ,CAAC,MAAM;QAClD,OAAO;YACH,MAAM;YACN,OAAO,QAAQ,KAAK,CAAC,GAAG,CAAC;QAC7B;IACJ;IACA,OAAO;AACX,EAEA,6CAA6C"}},
    {"offset": {"line": 341, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 345, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/dist/esm/server/dev/hot-reloader-types.js"],"sourcesContent":["export var HMR_ACTIONS_SENT_TO_BROWSER;\n(function(HMR_ACTIONS_SENT_TO_BROWSER) {\n    HMR_ACTIONS_SENT_TO_BROWSER[\"ADDED_PAGE\"] = \"addedPage\";\n    HMR_ACTIONS_SENT_TO_BROWSER[\"REMOVED_PAGE\"] = \"removedPage\";\n    HMR_ACTIONS_SENT_TO_BROWSER[\"RELOAD_PAGE\"] = \"reloadPage\";\n    HMR_ACTIONS_SENT_TO_BROWSER[\"SERVER_COMPONENT_CHANGES\"] = \"serverComponentChanges\";\n    HMR_ACTIONS_SENT_TO_BROWSER[\"MIDDLEWARE_CHANGES\"] = \"middlewareChanges\";\n    HMR_ACTIONS_SENT_TO_BROWSER[\"SERVER_ONLY_CHANGES\"] = \"serverOnlyChanges\";\n    HMR_ACTIONS_SENT_TO_BROWSER[\"SYNC\"] = \"sync\";\n    HMR_ACTIONS_SENT_TO_BROWSER[\"BUILT\"] = \"built\";\n    HMR_ACTIONS_SENT_TO_BROWSER[\"BUILDING\"] = \"building\";\n    HMR_ACTIONS_SENT_TO_BROWSER[\"DEV_PAGES_MANIFEST_UPDATE\"] = \"devPagesManifestUpdate\";\n    HMR_ACTIONS_SENT_TO_BROWSER[\"TURBOPACK_MESSAGE\"] = \"turbopack-message\";\n    HMR_ACTIONS_SENT_TO_BROWSER[\"SERVER_ERROR\"] = \"serverError\";\n    HMR_ACTIONS_SENT_TO_BROWSER[\"TURBOPACK_CONNECTED\"] = \"turbopack-connected\";\n})(HMR_ACTIONS_SENT_TO_BROWSER || (HMR_ACTIONS_SENT_TO_BROWSER = {}));\n\n//# sourceMappingURL=hot-reloader-types.js.map"],"names":[],"mappings":";;;AAAO,IAAI;AACX,CAAC,SAAS,2BAA2B;IACjC,2BAA2B,CAAC,aAAa,GAAG;IAC5C,2BAA2B,CAAC,eAAe,GAAG;IAC9C,2BAA2B,CAAC,cAAc,GAAG;IAC7C,2BAA2B,CAAC,2BAA2B,GAAG;IAC1D,2BAA2B,CAAC,qBAAqB,GAAG;IACpD,2BAA2B,CAAC,sBAAsB,GAAG;IACrD,2BAA2B,CAAC,OAAO,GAAG;IACtC,2BAA2B,CAAC,QAAQ,GAAG;IACvC,2BAA2B,CAAC,WAAW,GAAG;IAC1C,2BAA2B,CAAC,4BAA4B,GAAG;IAC3D,2BAA2B,CAAC,oBAAoB,GAAG;IACnD,2BAA2B,CAAC,eAAe,GAAG;IAC9C,2BAA2B,CAAC,sBAAsB,GAAG;AACzD,CAAC,EAAE,+BAA+B,CAAC,8BAA8B,CAAC,CAAC,IAEnE,8CAA8C"}},
    {"offset": {"line": 364, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}